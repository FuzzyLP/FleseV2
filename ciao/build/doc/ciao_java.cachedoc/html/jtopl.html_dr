section_env([file_top_section,pragmas([]),level(1)],global_label("Java to Prolog interface"),[string_esc("Java to Prolog interface")],[idx_env(def,lib,global_label("jtopl"),string_esc("jtopl"),[]),[[raw_nl,bf(string_esc("Author(s):")),string_esc(" "),[[defauthor(local_label("Jesus Correas"),[string_esc("Jes"),''''("u"),string_esc("s Correas")],[string_esc("Jes"),''''("u"),string_esc("s Correas")]),string_esc(".")]],p([])],[[],[]],[],[raw_nl,[[string_esc(" "),idx_env(use,cindex,localnum_label("0"),[string_esc("Java to Prolog interface")],[string_esc("Java to Prolog interface")]),string_esc(" "),string_esc("This module defines the Prolog side of the Java to Prolog interface. This side of the interface only has one public predicate: a server that listens at the socket connection with Java, and executes the commands received from the Java side."),p([]),string_esc("In order to evaluate the goals received from the Java side, this module can work in two ways: executing them in the same engine, or starting a thread for each goal. The easiest way is to launch them in the same engine, but the goals must be evaluated sequentially: once a goal provides the first solution, all the subsequent goals must be finished before this goal can backtrack to provide another solution. The Prolog side of this interface works as a top-level, and the goals partially evaluated are not independent."),p([]),string_esc("The solution of this goal dependence is to evaluate the goals in a different prolog engine. Although Ciao includes a mechanism to evaluate goals in different engines, the approach used in this interface is to launch each goal in a different thread."),p([]),string_esc("The decision of what kind of goal evaluation is selected is done by the Java side. Each evaluation type has its own command terms, so the Java side can choose the type it needs."),p([]),string_esc("A Prolog server starts by calling the "),tt([string_esc("prolog_server/0")]),string_esc(" "),string_esc("predicate, or by calling "),tt([string_esc("prolog_server/1")]),string_esc(" "),string_esc("predicate and providing the port number as argument. The user predicates and libraries to be called from Java must be included in the executable file, or be accesible using the built-in predicates dealing with code loading."),p([])]],linebreak]],show_toc(subparts),[section_env([with_parent,level(2)],local_label("Usage and interface"),string_esc("Usage and interface"),cartouche(itemize_env(bullet,[[item([]),bf([string_esc("Library usage"),string_esc(":")]),linebreak,tt(string_esc(":- use_module(library(javall/jtopl))."))],[item([]),bf([string_esc("Exports"),string_esc(":")]),linebreak,itemize_env(minus,[[[item([]),em([string_esc("Predicates"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("1"),string_esc("prolog_server/0"),string_esc("prolog_server/0")),string_esc(", ")],[idx_env(use,code,localnum_label("2"),string_esc("prolog_server/1"),string_esc("prolog_server/1")),string_esc(", ")],[idx_env(use,code,localnum_label("3"),string_esc("prolog_server/2"),string_esc("prolog_server/2")),string_esc(", ")],[idx_env(use,code,localnum_label("4"),string_esc("shell_s/0"),string_esc("shell_s/0")),string_esc(", ")],[idx_env(use,code,localnum_label("5"),string_esc("query_solutions/2"),string_esc("query_solutions/2")),string_esc(", ")],[idx_env(use,code,localnum_label("6"),string_esc("query_requests/2"),string_esc("query_requests/2")),string_esc(", ")],[idx_env(use,code,localnum_label("7"),string_esc("running_queries/2"),string_esc("running_queries/2")),string_esc(".")]],raw_nl]],nop,nop,nop,nop,nop],nop])],nop,nop,nop,nop]))),[],[],section_env([with_parent,level(2)],local_label("Documentation on exports"),string_esc("Documentation on exports"),[[defpred(local_label("prolog_server/0"),pred,"PREDICATE",prolog_server/0,[],[[],[[defassrt(check,[],"Usage:",[],[string_esc("Prolog server entry point. Reads from the standard input the node name and port number where the java client resides, and starts the prolog server listening at the jp socket. This predicate acts as a server: it includes an endless read-process loop until the "),tt([string_esc("prolog_halt")]),string_esc(" "),string_esc("command is received."),p([]),string_esc("However, from the low-level communication point of view, this Prolog server actually works as a client of the Java side. This means that Java side waits at the given port to a Prolog server trying to create a socket; Prolog side connects to that port, and then waits for Java requests (acting as a 'logical' server). To use this Prolog server as a real server waiting for connections at a given port, use "),tt([string_esc("prolog_server/1")]),string_esc("."),p([]),idx_env(use,cindex,localnum_label("8"),[string_esc("Prolog server")],[string_esc("Prolog server")]),string_esc(" ")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("prolog_server/1"),pred,"PREDICATE",prolog_server/1,[],[[],[[defassrt(check,[],"Usage:",[],[string_esc("Waits for incoming Java connections to act as a Prolog goal server for Java requests.This is the only "),tt([string_esc("prolog_server/*")]),string_esc(" "),string_esc("predicate that works as a true server: given a port number, waits for a connection from Java and then serves Java requests. When a termination request is received, finishes the connection to Java and waits next Java connection request. This behaviour is different with respect to previous versions of this library. To work as before, use "),tt([string_esc("prolog_server/2")]),string_esc("."),p([]),string_esc("Although it currently does not support simultaneous Java connections, some work is being done in that direction. "),idx_env(use,cindex,localnum_label("9"),[string_esc("Prolog server")],[string_esc("Prolog server")]),string_esc(" ")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is an atom.")],raw_nl],[[],[string_esc(" ("),[idx_env(use_noidx,prop,localnum_label("10"),string_esc("atm/1"),string_esc("basic_props:atm/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("prolog_server/2"),pred,"PREDICATE",prolog_server/2,[],[[],[[defassrt(check,[],"Usage:",[],[string_esc("Prolog server entry point. Given a network "),tt([string_esc("node")]),string_esc(" "),string_esc("and a "),tt([string_esc("port")]),string_esc(" "),string_esc("number, starts the prolog server trying to connect to Java side at that "),tt([string_esc("node:port")]),string_esc(" "),string_esc("address, and then waits for Java requests. This predicate acts as a server: it includes an endless read-process loop until the "),tt([string_esc("prolog_halt")]),string_esc(" "),string_esc("command is received."),p([]),string_esc("However, from the low-level communication point of view, this Prolog server actually works as a client of the Java side. This means that Java side waits at the given port to a Prolog server trying to create a socket; Prolog side connects to that port, and then waits for Java requests (acting as a 'logical' server). To use this Prolog server as a real server waiting for connections at a given port, use "),tt([string_esc("prolog_server/1")]),string_esc(". "),idx_env(use,cindex,localnum_label("11"),[string_esc("Prolog server")],[string_esc("Prolog server")]),string_esc(" ")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is an atom.")],raw_nl],[[],[string_esc(" ("),[idx_env(use_noidx,prop,localnum_label("12"),string_esc("atm/1"),string_esc("basic_props:atm/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is an atom.")],raw_nl],[[],[string_esc(" ("),[idx_env(use_noidx,prop,localnum_label("13"),string_esc("atm/1"),string_esc("basic_props:atm/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("shell_s/0"),pred,"PREDICATE",shell_s/0,[],[[],[[defassrt(check,[],"Usage:",[],[string_esc("Command execution loop. This predicate is called when the connection to Java is established, and performs an endless loop processing the commands received. This predicate is only intended to be used by the Prolog to Java interface and it should not be used by a user program.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("query_solutions/2"),pred,"PREDICATE",query_solutions/2,[],[string_esc("No further documentation available for this predicate."),[[],[[[raw_nl,string_esc("The predicate is of type "),em(string_esc("concurrent")),string_esc("."),linebreak],[]],[]],[[]]]]),sp("1"),raw_nl],[defpred(local_label("query_requests/2"),pred,"PREDICATE",query_requests/2,[],[string_esc("No further documentation available for this predicate."),[[],[[[raw_nl,string_esc("The predicate is of type "),em(string_esc("concurrent")),string_esc("."),linebreak],[]],[]],[[]]]]),sp("1"),raw_nl],[defpred(local_label("running_queries/2"),pred,"PREDICATE",running_queries/2,[],[string_esc("No further documentation available for this predicate."),[[],[[[raw_nl,string_esc("The predicate is of type "),em(string_esc("concurrent")),string_esc("."),linebreak],[]],[]],[[]]]]),sp("1"),raw_nl]]),[],[],section_env([with_parent,level(2)],local_label("Documentation on imports"),string_esc("Documentation on imports"),[string_esc("This module has the following direct dependencies:"),itemize_env(minus,[[item([]),em([string_esc("Application modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("14"),string_esc("javasock"),string_esc("javasock")),string_esc(".")]],raw_nl]],nop,[item([]),em([string_esc("System library modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("15"),string_esc("datafacts_rt"),string_esc("datafacts_rt")),string_esc(", ")],[idx_env(use,code,localnum_label("16"),string_esc("concurrency"),string_esc("concurrency")),string_esc(", ")],[idx_env(use,code,localnum_label("17"),string_esc("system"),string_esc("system")),string_esc(", ")],[idx_env(use,code,localnum_label("18"),string_esc("read"),string_esc("read")),string_esc(", ")],[idx_env(use,code,localnum_label("19"),string_esc("compiler"),string_esc("compiler")),string_esc(", ")],[idx_env(use,code,localnum_label("20"),string_esc("read_from_string"),string_esc("read_from_string")),string_esc(".")]],raw_nl]],nop,[item([]),em([string_esc("Packages"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("21"),string_esc("prelude"),string_esc("prelude")),string_esc(", ")],[idx_env(use,code,localnum_label("22"),string_esc("initial"),string_esc("initial")),string_esc(", ")],[idx_env(use,code,localnum_label("23"),string_esc("condcomp"),string_esc("condcomp")),string_esc(", ")],[idx_env(use,code,localnum_label("24"),string_esc("assertions"),string_esc("assertions")),string_esc(", ")],[idx_env(use,code,localnum_label("25"),string_esc("assertions/assertions_basic"),string_esc("assertions/assertions_basic")),string_esc(", ")],[idx_env(use,code,localnum_label("26"),string_esc("regtypes"),string_esc("regtypes")),string_esc(", ")],[idx_env(use,code,localnum_label("27"),string_esc("isomodes"),string_esc("isomodes")),string_esc(", ")],[idx_env(use,code,localnum_label("28"),string_esc("datafacts"),string_esc("datafacts")),string_esc(".")]],raw_nl]]])])]]).