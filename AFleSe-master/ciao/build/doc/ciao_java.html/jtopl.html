<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><title>Java to Prolog interface &mdash; Prolog/Java Bidirectional Interface</title></head><body><div class="nav"><span class="on_right"><a class="navbutton" href="javall_doc.html">&#x25B2;</a><a class="navbutton" href="javart.html">&#x25C4;</a><a class="navbutton" href="javasock.html">&#x25BA;</a></span><span><a href="javall_doc.html">Prolog/Java Bidirectional Interface</a> &raquo; </span></div><div class="documentwrapper"><div class="document"><div class="mainwrapper"><div class="main"><div id=""><h1>Java to Prolog interface</h1><a class="idx_anchor" href="javall_docliindex.html#jtopl"></a>
<strong>Author(s):</strong> <a class="idx_anchor" id="Jesus Correas" href="javall_docauindex.html#Jesus Correas">Jes&uacute;s Correas</a>.<p>
 <a class="idx_anchor" id="0" href="javall_doccoindex.html#Java to Prolog interface"></a> This module defines the Prolog side of the Java to Prolog interface. This side of the interface only has one public predicate: a server that listens at the socket connection with Java, and executes the commands received from the Java side.<p>In order to evaluate the goals received from the Java side, this module can work in two ways: executing them in the same engine, or starting a thread for each goal. The easiest way is to launch them in the same engine, but the goals must be evaluated sequentially: once a goal provides the first solution, all the subsequent goals must be finished before this goal can backtrack to provide another solution. The Prolog side of this interface works as a top-level, and the goals partially evaluated are not independent.<p>The solution of this goal dependence is to evaluate the goals in a different prolog engine. Although Ciao includes a mechanism to evaluate goals in different engines, the approach used in this interface is to launch each goal in a different thread.<p>The decision of what kind of goal evaluation is selected is done by the Java side. Each evaluation type has its own command terms, so the Java side can choose the type it needs.<p>A Prolog server starts by calling the <tt>prolog_server/0</tt> predicate, or by calling <tt>prolog_server/1</tt> predicate and providing the port number as argument. The user predicates and libraries to be called from Java must be included in the executable file, or be accesible using the built-in predicates dealing with code loading.<p><br/><div id="Usage and interface"><h2>Usage and interface</h2><div class="cartouche"><ul><LI><strong>Library usage:</strong><br/><tt>:- use_module(library(javall/jtopl)).</tt><LI><strong>Exports:</strong><br/><ul class="itemize_minus"><LI><em>Predicates:</em><br/><a class="idx_anchor" id="1" href="javall_docglindex.html#prolog_server/0"><tt>prolog_server/0</tt></a>, <a class="idx_anchor" id="2" href="javall_docglindex.html#prolog_server/1"><tt>prolog_server/1</tt></a>, <a class="idx_anchor" id="3" href="javall_docglindex.html#prolog_server/2"><tt>prolog_server/2</tt></a>, <a class="idx_anchor" id="4" href="javall_docglindex.html#shell_s/0"><tt>shell_s/0</tt></a>, <a class="idx_anchor" id="5" href="javall_docglindex.html#query_solutions/2"><tt>query_solutions/2</tt></a>, <a class="idx_anchor" id="6" href="javall_docglindex.html#query_requests/2"><tt>query_requests/2</tt></a>, <a class="idx_anchor" id="7" href="javall_docglindex.html#running_queries/2"><tt>running_queries/2</tt></a>.
</ul><LI><strong>Imports:</strong><br/><ul class="itemize_minus"><LI><em>Application modules:</em><br/><a class="idx_anchor" id="8" href="javall_docglindex.html#javasock"><tt>javasock</tt></a>.
<LI><em>System library modules:</em><br/><a class="idx_anchor" id="9" href="javall_docglindex.html#concurrency"><tt>concurrency</tt></a>, <a class="idx_anchor" id="10" href="javall_docglindex.html#system"><tt>system</tt></a>, <a class="idx_anchor" id="11" href="javall_docglindex.html#read"><tt>read</tt></a>, <a class="idx_anchor" id="12" href="javall_docglindex.html#compiler"><tt>compiler</tt></a>, <a class="idx_anchor" id="13" href="javall_docglindex.html#read_from_string"><tt>read_from_string</tt></a>.
<LI><em>Packages:</em><br/><a class="idx_anchor" id="14" href="javall_docglindex.html#prelude"><tt>prelude</tt></a>, <a class="idx_anchor" id="15" href="javall_docglindex.html#nonpure"><tt>nonpure</tt></a>, <a class="idx_anchor" id="16" href="javall_docglindex.html#condcomp"><tt>condcomp</tt></a>, <a class="idx_anchor" id="17" href="javall_docglindex.html#assertions"><tt>assertions</tt></a>, <a class="idx_anchor" id="18" href="javall_docglindex.html#regtypes"><tt>regtypes</tt></a>, <a class="idx_anchor" id="19" href="javall_docglindex.html#isomodes"><tt>isomodes</tt></a>.
</ul></ul></div></div><div id="Documentation on exports"><h2>Documentation on exports</h2><div><span class="predtag_on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="prolog_server/0" href="javall_docpdindex.html#prolog_server/0">prolog_server/0</a>:</div><div class="deftext"><p><span class="check_header"><strong>Usage:</strong></span><span class="usagedecl"></span><p>Prolog server entry point. Reads from the standard input the node name and port number where the java client resides, and starts the prolog server listening at the jp socket. This predicate acts as a server: it includes an endless read-process loop until the <tt>prolog_halt</tt> command is received.<p>However, from the low-level communication point of view, this Prolog server actually works as a client of the Java side. This means that Java side waits at the given port to a Prolog server trying to create a socket; Prolog side connects to that port, and then waits for Java requests (acting as a &apos;logical&apos; server). To use this Prolog server as a real server waiting for connections at a given port, use <tt>prolog_server/1</tt>.<p><a class="idx_anchor" id="20" href="javall_doccoindex.html#Prolog server"></a> </p><ul class="itemize_minus"></ul></div></div><p>
<div><span class="predtag_on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="prolog_server/1" href="javall_docpdindex.html#prolog_server/1">prolog_server/1</a>:</div><div class="deftext"><p><span class="check_header"><strong>Usage:</strong></span><span class="usagedecl"></span><p>Waits for incoming Java connections to act as a Prolog goal server for Java requests.This is the only <tt>prolog_server/*</tt> predicate that works as a true server: given a port number, waits for a connection from Java and then serves Java requests. When a termination request is received, finishes the connection to Java and waits next Java connection request. This behaviour is different with respect to previous versions of this library. To work as before, use <tt>prolog_server/2</tt>.<p>Although it currently does not support simultaneous Java connections, some work is being done in that direction. <a class="idx_anchor" id="21" href="javall_doccoindex.html#Prolog server"></a> </p><ul class="itemize_minus"><LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">Arg1</span> is an atom.
</span>
</ul></div></div><p>
<div><span class="predtag_on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="prolog_server/2" href="javall_docpdindex.html#prolog_server/2">prolog_server/2</a>:</div><div class="deftext"><p><span class="check_header"><strong>Usage:</strong></span><span class="usagedecl"></span><p>Prolog server entry point. Given a network <tt>node</tt> and a <tt>port</tt> number, starts the prolog server trying to connect to Java side at that <tt>node:port</tt> address, and then waits for Java requests. This predicate acts as a server: it includes an endless read-process loop until the <tt>prolog_halt</tt> command is received.<p>However, from the low-level communication point of view, this Prolog server actually works as a client of the Java side. This means that Java side waits at the given port to a Prolog server trying to create a socket; Prolog side connects to that port, and then waits for Java requests (acting as a &apos;logical&apos; server). To use this Prolog server as a real server waiting for connections at a given port, use <tt>prolog_server/1</tt>. <a class="idx_anchor" id="22" href="javall_doccoindex.html#Prolog server"></a> </p><ul class="itemize_minus"><LI><em>Call and exit should be compatible with:</em><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">Arg1</span> is an atom.
</span><br/><span class="on_right"> (basic_props:atm/1)</span><span><span class="var">Arg2</span> is an atom.
</span>
</ul></div></div><p>
<div><span class="predtag_on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="shell_s/0" href="javall_docpdindex.html#shell_s/0">shell_s/0</a>:</div><div class="deftext"><p><span class="check_header"><strong>Usage:</strong></span><span class="usagedecl"></span><p>Command execution loop. This predicate is called when the connection to Java is established, and performs an endless loop processing the commands received. This predicate is only intended to be used by the Prolog to Java interface and it should not be used by a user program.</p><ul class="itemize_minus"></ul></div></div><p>
<div><span class="predtag_on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="query_solutions/2" href="javall_docpdindex.html#query_solutions/2">query_solutions/2</a>:</div><div class="deftext">No further documentation available for this predicate.
The predicate is of type <em>concurrent</em>.<br/></div></div><p>
<div><span class="predtag_on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="query_requests/2" href="javall_docpdindex.html#query_requests/2">query_requests/2</a>:</div><div class="deftext">No further documentation available for this predicate.
The predicate is of type <em>concurrent</em>.<br/></div></div><p>
<div><span class="predtag_on_right">PREDICATE</span><div class="defname"><a class="idx_anchor" id="running_queries/2" href="javall_docpdindex.html#running_queries/2">running_queries/2</a>:</div><div class="deftext">No further documentation available for this predicate.
The predicate is of type <em>concurrent</em>.<br/></div></div><p>
</div></div></div></div></div><div class="sidebarwrapper"><div class="sidebar"><h2>Module Sections</h2><ul><li><a href="#Usage and interface">Usage and interface</a></li><li><a href="#Documentation on exports">Documentation on exports</a></li></ul><h2>Global Links</h2><ul><li><a href="javall_docfulltoc.html">Table of Contents</a></li><li><a href="javall_docrefs.html">References</a></li><li><a href="javall_doccopyright.html">Copyright</a></li></ul><h2>Indices</h2><ul><li><a href="javall_docliindex.html">Library/Module Index</a></li><li><a href="javall_docpdindex.html">Predicate/Method Index</a></li><li><a href="javall_docprindex.html">Property Index</a></li><li><a href="javall_docteindex.html">Regular Type Index</a></li><li><a href="javall_docdeindex.html">Declaration Index</a></li><li><a href="javall_doccoindex.html">Concept Index</a></li><li><a href="javall_docauindex.html">Author Index</a></li><li><a href="javall_docglindex.html">Global Index</a></li></ul></div></div><div class="clearer"></div></div><div class="nav"><span class="on_right"><a class="navbutton" href="javall_doc.html">&#x25B2;</a><a class="navbutton" href="javart.html">&#x25C4;</a><a class="navbutton" href="javasock.html">&#x25BA;</a></span><span>&nbsp;</span></div><div class="footer">Generated with LPdoc using Ciao</div></body></html>