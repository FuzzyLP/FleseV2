section_env([file_top_section,pragmas([]),level(1)],global_label("Prolog to Java interface"),[string_esc("Prolog to Java interface")],[idx_env(def,lib,global_label("javart"),string_esc("javart"),[]),[[raw_nl,bf(string_esc("Author(s):")),string_esc(" "),[[defauthor(local_label("Jesus Correas"),[string_esc("Jes"),''''("u"),string_esc("s Correas")],[string_esc("Jes"),''''("u"),string_esc("s Correas")]),string_esc(".")]],p([])],[[],[]],[],[raw_nl,[p([]),string_esc("This module defines the Ciao Prolog to Java interface. This interface allows a Prolog program to start a Java process, create Java objects, invoke methods, set/get attributes (fields), and handle Java events."),p([]),string_esc("This interface only works with JDK version 1.2 or higher."),p([]),string_esc("Although the Java side interface is explained in Javadoc format (it is available at "),tt([string_esc("library/javall/javadoc/")]),string_esc(" "),string_esc("in your Ciao installation), the general interface structure is detailed here."),p([]),section_env([level(2)],local_label("Prolog to Java Interface Structure"),[string_esc("Prolog to Java Interface Structure")],[string_esc(" "),idx_env(use,cindex,localnum_label("0"),[string_esc("Prolog to Java Interface Structure")],[string_esc("Prolog to Java Interface Structure")]),string_esc(" "),string_esc("This interface is made up of two parts: a Prolog part and a Java part, running in separate processes. The Prolog part receives requests from a Prolog program and sends them to the Java part through a socket. The Java part receives requests from the socket and performs the actions included in the requests."),p([]),string_esc("If an event is thrown in the Java side, an asynchronous message must be sent away to the Prolog side, in order to launch a Prolog goal to handle the event. This asynchronous communication is performed using a separate socket. The nature of this communication needs the use of threads both in Java and Prolog: to deal with the 'sequential program flow,' and other threads for event handling."),p([]),string_esc("In both sides the threads are automatically created by the context of the objects we use. The user must be aware that different requests to the other side of the interface could run concurrently."),p([]),string_esc(" "),section_env([level(3)],local_label("Prolog side of the Java interface"),[string_esc("Prolog side of the Java interface")],[string_esc(" "),idx_env(use,cindex,localnum_label("1"),[string_esc("Prolog to Java Interface Structure. Prolog side")],[string_esc("Prolog to Java Interface Structure. Prolog side")]),string_esc(" "),string_esc("The Prolog side receives the actions to do in the Java side from the user program, and sends them to the Java process through the socket connection. When the action is done in the Java side, the result is returned to the user Prolog program, or the action fails if there is any problem in the Java side."),p([]),string_esc("Prolog data representation of Java elements is very simple in this interface. Java primitive types such as integers and characters are translated into the Prolog corresponding terms, and even some Java objects are translated in the same way (e. g. Java strings). Java objects are represented in Prolog as compound terms with a reference id to identify the corresponding Java object. Data conversion is made automatically when the interface is used, so the Prolog user programs do not have to deal with the complexity of these tasks."),p([])]),section_env([level(3)],local_label("Java side"),[string_esc("Java side")],[string_esc(" "),idx_env(use,cindex,localnum_label("2"),[string_esc("Prolog to Java Interface Structure. Java side")],[string_esc("Prolog to Java Interface Structure. Java side")]),string_esc(" "),string_esc("The Java side of this layer is more complex than the Prolog side. The tasks this part has to deal with are the following:"),p([]),env_(itemize,[string_esc(" "),p([]),item([]),string_esc("Wait for requests from the Prolog side."),p([]),item([]),string_esc("Translate the Prolog terms received in the Prolog 'serialized' form to a more useful Java representation (see the Java interface documentation available at "),tt([string_esc("library/javall/javadoc/")]),string_esc(" "),string_esc("in your Ciao installation for details regarding Java representation of Prolog terms)."),p([]),item([]),string_esc("Interpret the requests received from the Prolog side, and execute them."),p([]),item([]),string_esc("Handle the set of objects created by or derived from the requests received from the prolog side."),p([]),item([]),string_esc("Handle the events raised in the Java side, and launch the listeners added in the prolog side."),p([]),item([]),string_esc("Handle the exceptions raised in the Java side, and send them to the Prolog side."),p([])]),string_esc(" "),p([]),string_esc("In the implementation of the Java side, two items must be carefully designed: the handling of Java objects, and the representation of prolog data structures. The last item is specially important because all the interactions between Prolog and Java are made using Prolog structures, an easy way to standardize the different data management in both sides. Even the requests themselves are encapsulated using Prolog structures. The overload of this encapsulation is not significant in terms of socket traffic, due to the optimal implementation of the prolog serialized term."),p([]),string_esc("The java side must handle the objects created from the Prolog side dinamically, and these objects must be accessed as fast as possible from the set of objects. The Java API provides a powerful implementation of Hash tables that achieves all the requirements of our implementation."),p([]),string_esc("On the other hand, the java representation of prolog terms is made using the inheritance of java classes. In the java side there exists a representation of a generic prolog term, implemented as an abstract class in java. Variables, atoms, compound terms, lists, and numeric terms are classes in the java side which inherit from the term class. Java objects can be seen also under the prolog representation as compound terms, where the single argument corresponds to the Hash key of the actual java object in the Hash table referred to before. This behaviour makes the handling of mixed java and prolog elements easy. Prolog goals are represented in the java side as objects which contain a prolog compound term with the term representing the goal. This case will be seen more in depth in next chapter, where the java to prolog interface is explained."),p([])])]),section_env([level(2)],local_label("Java event handling from Prolog"),[string_esc("Java event handling from Prolog")],[string_esc(" "),idx_env(use,cindex,localnum_label("3"),[string_esc("Java event handling from Prolog")],[string_esc("Java event handling from Prolog")]),string_esc(" "),string_esc("Java event handling is based on a delegation model since version 1.1.x. This approach to event handling is very powerful and elegant, but a user program cannot handle all the events that can arise on a given object: for each kind of event, a listener must be implemented and added specifically. However, the Java 2 API includes a special listener ("),tt([string_esc("AWTEventListener")]),string_esc(") that can manage the internal java event queue."),p([]),string_esc("The prolog to java interface has been designed to emulate the java event handler, and is also based on event objects and listeners. The prolog to java interface implements its own event manager, to handle those events that have prolog listeners associated to the object that raises the event. From the prolog side can be added listeners to objects for specific events. The java side includes a list of goals to launch from the object and event type."),p([]),string_esc("Due to the events nature, the event handler must work in a separate thread to manage the events asynchronously. The java side has its own mechanisms to work this way. The prolog side must be implemented specially for event handling using threads. The communication between java and prolog is also asynchronous, and an additional socket stream is used to avoid interferences with the main socket stream. The event stream will work in this implementation only in one way: from java to prolog. If an event handler needs to send back requests to java, it will use the main socket stream, just like the requests sent directly from a prolog program."),p([]),string_esc("The internal process of register a Prolog event handler to a Java event is shown in the next figure:"),p([]),image("javall/autofig/ip2jbn-events-pl-reg"),string_esc(" "),p([]),string_esc("When an event raises, the Prolog to Java interface has to send to the Prolog user program the goal to evaluate. Graphically, the complete process takes the tasks involved in the following figure:"),p([]),image("javall/autofig/ip2jbn-events-pl-fire"),string_esc(" "),p([]),string_esc(" ")]),section_env([level(2)],local_label("Java exception handling from Prolog"),[string_esc("Java exception handling from Prolog")],[string_esc(" "),idx_env(use,cindex,localnum_label("4"),[string_esc("Java exception handling from Prolog")],[string_esc("Java exception handling from Prolog")]),string_esc(" "),string_esc("Java exception handling is very similar to the peer prolog handling: it includes some specific statements to trap exceptions from user code. In the java side, the exceptions can be originated from an incorrect request, or can be originated in the code called from the request. Both exception types will be sent to prolog using the main socket stream, allowing the prolog program manage the exception. However, the first kind of exceptions are prefixed, so the user program can distinguish them from the second type of exceptions."),p([]),string_esc("In order to handle exceptions properly using the prolog to java and java to prolog interfaces simultaneously, in both sides of the interface those exceptions coming from their own side will be filtered: this avoids an endless loop of exceptions bouncing from one side to another."),p([])])],linebreak]],show_toc(toc_view(no)),[section_env([with_parent,level(2)],local_label("Usage and interface"),string_esc("Usage and interface"),cartouche(itemize_env(bullet,[[item([]),bf([string_esc("Library usage"),string_esc(":")]),linebreak,tt(string_esc(":- use_module(library(javall/javart))."))],[item([]),bf([string_esc("Exports"),string_esc(":")]),linebreak,itemize_env(minus,[[[item([]),em([string_esc("Predicates"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("5"),string_esc("java_start/0"),string_esc("java_start/0")),string_esc(", ")],[idx_env(use,code,localnum_label("6"),string_esc("java_start/1"),string_esc("java_start/1")),string_esc(", ")],[idx_env(use,code,localnum_label("7"),string_esc("java_start/2"),string_esc("java_start/2")),string_esc(", ")],[idx_env(use,code,localnum_label("8"),string_esc("java_stop/0"),string_esc("java_stop/0")),string_esc(", ")],[idx_env(use,code,localnum_label("9"),string_esc("java_connect/2"),string_esc("java_connect/2")),string_esc(", ")],[idx_env(use,code,localnum_label("10"),string_esc("java_disconnect/0"),string_esc("java_disconnect/0")),string_esc(", ")],[idx_env(use,code,localnum_label("11"),string_esc("java_use_module/1"),string_esc("java_use_module/1")),string_esc(", ")],[idx_env(use,code,localnum_label("12"),string_esc("java_create_object/2"),string_esc("java_create_object/2")),string_esc(", ")],[idx_env(use,code,localnum_label("13"),string_esc("java_delete_object/1"),string_esc("java_delete_object/1")),string_esc(", ")],[idx_env(use,code,localnum_label("14"),string_esc("java_invoke_method/2"),string_esc("java_invoke_method/2")),string_esc(", ")],[idx_env(use,code,localnum_label("15"),string_esc("java_get_value/2"),string_esc("java_get_value/2")),string_esc(", ")],[idx_env(use,code,localnum_label("16"),string_esc("java_set_value/2"),string_esc("java_set_value/2")),string_esc(", ")],[idx_env(use,code,localnum_label("17"),string_esc("java_add_listener/3"),string_esc("java_add_listener/3")),string_esc(", ")],[idx_env(use,code,localnum_label("18"),string_esc("java_remove_listener/3"),string_esc("java_remove_listener/3")),string_esc(".")]],raw_nl]],nop,nop,nop,[item([]),em([string_esc("Regular Types"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("19"),string_esc("machine_name/1"),string_esc("machine_name/1")),string_esc(", ")],[idx_env(use,code,localnum_label("20"),string_esc("java_constructor/1"),string_esc("java_constructor/1")),string_esc(", ")],[idx_env(use,code,localnum_label("21"),string_esc("java_object/1"),string_esc("java_object/1")),string_esc(", ")],[idx_env(use,code,localnum_label("22"),string_esc("java_event/1"),string_esc("java_event/1")),string_esc(", ")],[idx_env(use,code,localnum_label("23"),string_esc("prolog_goal/1"),string_esc("prolog_goal/1")),string_esc(", ")],[idx_env(use,code,localnum_label("24"),string_esc("java_field/1"),string_esc("java_field/1")),string_esc(", ")],[idx_env(use,code,localnum_label("25"),string_esc("java_method/1"),string_esc("java_method/1")),string_esc(".")]],raw_nl]],nop],nop])],nop,nop,nop,[item([]),bf([string_esc("Imports"),string_esc(":")]),linebreak,itemize_env(minus,[[item([]),em([string_esc("Application modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("26"),string_esc("javasock"),string_esc("javasock")),string_esc(".")]],raw_nl]],nop,[item([]),em([string_esc("System library modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("27"),string_esc("concurrency"),string_esc("concurrency")),string_esc(", ")],[idx_env(use,code,localnum_label("28"),string_esc("iso_char"),string_esc("iso_char")),string_esc(", ")],[idx_env(use,code,localnum_label("29"),string_esc("lists"),string_esc("lists")),string_esc(", ")],[idx_env(use,code,localnum_label("30"),string_esc("read"),string_esc("read")),string_esc(", ")],[idx_env(use,code,localnum_label("31"),string_esc("write"),string_esc("write")),string_esc(", ")],[idx_env(use,code,localnum_label("32"),string_esc("process"),string_esc("process")),string_esc(", ")],[idx_env(use,code,localnum_label("33"),string_esc("system"),string_esc("system")),string_esc(".")]],raw_nl]],nop,[item([]),em([string_esc("Packages"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("34"),string_esc("prelude"),string_esc("prelude")),string_esc(", ")],[idx_env(use,code,localnum_label("35"),string_esc("nonpure"),string_esc("nonpure")),string_esc(", ")],[idx_env(use,code,localnum_label("36"),string_esc("condcomp"),string_esc("condcomp")),string_esc(", ")],[idx_env(use,code,localnum_label("37"),string_esc("assertions"),string_esc("assertions")),string_esc(", ")],[idx_env(use,code,localnum_label("38"),string_esc("regtypes"),string_esc("regtypes")),string_esc(", ")],[idx_env(use,code,localnum_label("39"),string_esc("isomodes"),string_esc("isomodes")),string_esc(".")]],raw_nl]]])]]))),[],[],section_env([with_parent,level(2)],local_label("Documentation on exports"),string_esc("Documentation on exports"),[[defpred(local_label("java_start/0"),pred,"PREDICATE",java_start/0,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Starts the Java server on the local machine, connects to it, and starts the event handling thread.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_start/1"),pred,"PREDICATE",java_start/1,[[],[],[[defassrt(check,pred,"Usage:",[[string_esc([]),tt(string_esc("java_start(Classpath)")),string_esc([])],raw_nl],[string_esc("Starts the Java server on the local machine, connects to it, and starts the event handling thread. The Java server is started using the classpath received as argument.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Classpath")]),string_esc(" "),string_esc("is a string (a list of character codes).")],raw_nl],[[],[string_esc(" ("),[string_esc("basic_props:string/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Classpath")]),string_esc(" "),string_esc("is currently a term which is not a free variable.")],raw_nl],[[],[string_esc(" ("),[string_esc("term_typing:nonvar/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_start/2"),pred,"PREDICATE",java_start/2,[[],[],[[defassrt(check,pred,"Usage:",[[string_esc([]),tt(string_esc("java_start(Machine_name,Classpath)")),string_esc([])],raw_nl],[string_esc("Starts the Java server in "),var([string_esc("machine_name")]),string_esc(" "),string_esc("(using rsh!), connects to it, and starts the event handling thread. The Java server is started using the "),var([string_esc("Classpath")]),string_esc(" "),string_esc("received as argument.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Machine_name")]),string_esc(" "),string_esc("is the network name of a machine.")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:machine_name/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Classpath")]),string_esc(" "),string_esc("is a string (a list of character codes).")],raw_nl],[[],[string_esc(" ("),[string_esc("basic_props:string/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Machine_name")]),string_esc(" "),string_esc("is currently a term which is not a free variable.")],raw_nl],[[],[string_esc(" ("),[string_esc("term_typing:nonvar/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Classpath")]),string_esc(" "),string_esc("is currently a term which is not a free variable.")],raw_nl],[[],[string_esc(" ("),[string_esc("term_typing:nonvar/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_stop/0"),pred,"PREDICATE",java_stop/0,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Stops the interface terminating the threads that handle the socket connection, and finishing the Java interface server if it was started using java_start/n.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_connect/2"),pred,"PREDICATE",java_connect/2,[[],[],[[defassrt(check,pred,"Usage:",[[string_esc([]),tt(string_esc("java_connect(Machine_name,Port_number)")),string_esc([])],raw_nl],[string_esc("Connects to an existing Java interface server running in "),var([string_esc("Machine_name")]),string_esc(" "),string_esc("and listening at port "),var([string_esc("port_number")]),string_esc(". To connect to a Java server located in the local machine, use 'localhost' as machine_name.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Machine_name")]),string_esc(" "),string_esc("is the network name of a machine.")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:machine_name/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Port_number")]),string_esc(" "),string_esc("is an integer.")],raw_nl],[[],[string_esc(" ("),[string_esc("basic_props:int/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Machine_name")]),string_esc(" "),string_esc("is currently a term which is not a free variable.")],raw_nl],[[],[string_esc(" ("),[string_esc("term_typing:nonvar/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Port_number")]),string_esc(" "),string_esc("is currently a term which is not a free variable.")],raw_nl],[[],[string_esc(" ("),[string_esc("term_typing:nonvar/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_disconnect/0"),pred,"PREDICATE",java_disconnect/0,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Closes the connection with the java process, terminating the threads that handle the connection to Java. This predicate does not terminate the Java process (this is the disconnection procedure for Java servers not started from Prolog). This predicate should be used when the communication is established with java_connect/2.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("machine_name/1"),regtype,"REGTYPE",machine_name/1,[[],[],[[defassrt(check,prop,"Usage:",[[string_esc([]),tt(string_esc("machine_name(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is the network name of a machine.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_constructor/1"),regtype,"REGTYPE",java_constructor/1,[[],[],[[defassrt(check,prop,"Usage:",[[string_esc([]),tt(string_esc("java_constructor(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a java constructor (structure with functor as constructor full name, and arguments as constructor arguments).")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_object/1"),regtype,"REGTYPE",java_object/1,[[],[],[[defassrt(check,prop,"Usage:",[[string_esc([]),tt(string_esc("java_object(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_event/1"),regtype,"REGTYPE",java_event/1,[[],[],[[defassrt(check,prop,"Usage:",[[string_esc([]),tt(string_esc("java_event(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a java event represented as an atom with the full event constructor name (e.g., 'java.awt.event.ActionListener').")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("prolog_goal/1"),regtype,"REGTYPE",prolog_goal/1,[[],[],[[defassrt(check,prop,"Usage:",[[string_esc([]),tt(string_esc("prolog_goal(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a prolog predicate. Prolog term that represents the goal that must be invoked when the event raises on the object. The predicate arguments can be java objects, or even the result of java methods. These java objects will be evaluated when the event raises (instead of when the listener is added). The arguments that represent java objects must be instantiated to already created objects. The variables will be kept uninstantiated when the event raises and the predicate is called.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_field/1"),regtype,"REGTYPE",java_field/1,[[],[],[[defassrt(check,prop,"Usage:",[[string_esc([]),tt(string_esc("java_field(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a java field (structure on which the functor name is the field name, and the single argument is the field value).")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_use_module/1"),pred,"PREDICATE",java_use_module/1,[[],[],[[defassrt(check,pred,"Usage:",[[string_esc([]),tt(string_esc("java_use_module(Module)")),string_esc([])],raw_nl],[string_esc("Loads a module and makes it available from Java.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Module")]),string_esc(" "),string_esc("is any term.")],raw_nl],[[],[string_esc(" ("),[string_esc("basic_props:term/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Module")]),string_esc(" "),string_esc("is currently a term which is not a free variable.")],raw_nl],[[],[string_esc(" ("),[string_esc("term_typing:nonvar/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_create_object/2"),pred,"PREDICATE",java_create_object/2,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("New java object creation. The constructor must be a compound term as defined by its type, with the full class name as functor (e.g., 'java.lang.String'), and the parameters passed to the constructor as arguments of the structure.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java constructor (structure with functor as constructor full name, and arguments as constructor arguments).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_constructor/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java constructor (structure with functor as constructor full name, and arguments as constructor arguments).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_constructor/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a free variable.")],raw_nl],[[],[string_esc(" ("),[string_esc("term_typing:var/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold upon exit:"))],[[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])]],raw_nl],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_delete_object/1"),pred,"PREDICATE",java_delete_object/1,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Java object deletion. It removes the object given as argument from the Java object table.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_invoke_method/2"),pred,"PREDICATE",java_invoke_method/2,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Invokes a java method on an object. Given a Java object reference, invokes the method represented with the second argument. ")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java method (structure with functor as method name, and arguments as method ones, plus a result argument. This result argument is unified with the atom 'Yes' if the java method returns void).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_method/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java method (structure with functor as method name, and arguments as method ones, plus a result argument. This result argument is unified with the atom 'Yes' if the java method returns void).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_method/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_method/1"),regtype,"REGTYPE",java_method/1,[[],[],[[defassrt(check,prop,"Usage:",[[string_esc([]),tt(string_esc("java_method(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a java method (structure with functor as method name, and arguments as method ones, plus a result argument. This result argument is unified with the atom 'Yes' if the java method returns void).")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_get_value/2"),pred,"PREDICATE",java_get_value/2,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Gets the value of a field. Given a Java object as first argument, it instantiates the variable given as second argument. This field must be uninstantiated in the java_field functor, or this predicate will fail.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java field (structure on which the functor name is the field name, and the single argument is the field value).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_field/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java field (structure on which the functor name is the field name, and the single argument is the field value).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_field/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_set_value/2"),pred,"PREDICATE",java_set_value/2,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Sets the value of a Java object field. Given a Java object reference, it assigns the value included in the java_field compound term. The field value in the java_field structure must be instantiated.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java field (structure on which the functor name is the field name, and the single argument is the field value).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_field/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java field (structure on which the functor name is the field name, and the single argument is the field value).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_field/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("java_add_listener/3"),pred,"PREDICATE",java_add_listener/3,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("Adds a listener to an event on an object. Given a Java object reference, it registers the goal received as third argument to be launched when the Java event raises.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java event represented as an atom with the full event constructor name (e.g., 'java.awt.event.ActionListener').")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_event/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg3")]),string_esc(" "),string_esc("is a prolog predicate. Prolog term that represents the goal that must be invoked when the event raises on the object. The predicate arguments can be java objects, or even the result of java methods. These java objects will be evaluated when the event raises (instead of when the listener is added). The arguments that represent java objects must be instantiated to already created objects. The variables will be kept uninstantiated when the event raises and the predicate is called.")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:prolog_goal/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java event represented as an atom with the full event constructor name (e.g., 'java.awt.event.ActionListener').")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_event/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg3")]),string_esc(" "),string_esc("is a prolog predicate. Prolog term that represents the goal that must be invoked when the event raises on the object. The predicate arguments can be java objects, or even the result of java methods. These java objects will be evaluated when the event raises (instead of when the listener is added). The arguments that represent java objects must be instantiated to already created objects. The variables will be kept uninstantiated when the event raises and the predicate is called.")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:prolog_goal/1")],string_esc(")")]])]],raw_nl],[],[]))],[[[],[raw_nl,em(string_esc("Meta-predicate")),string_esc(" with arguments: "),tt(string_esc("java_add_listener(?,?,goal)")),string_esc("."),linebreak]],[]],[[]]]]),sp("1"),raw_nl],[defpred(local_label("java_remove_listener/3"),pred,"PREDICATE",java_remove_listener/3,[[],[],[[defassrt(check,pred,"Usage:",[],[string_esc("It removes a listener from an object event queue. Given a Java object reference, goal registered for the given event is removed.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java event represented as an atom with the full event constructor name (e.g., 'java.awt.event.ActionListener').")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_event/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg3")]),string_esc(" "),string_esc("is a prolog predicate. Prolog term that represents the goal that must be invoked when the event raises on the object. The predicate arguments can be java objects, or even the result of java methods. These java objects will be evaluated when the event raises (instead of when the listener is added). The arguments that represent java objects must be instantiated to already created objects. The variables will be kept uninstantiated when the event raises and the predicate is called.")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:prolog_goal/1")],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("Arg1")]),string_esc(" "),string_esc("is a java object (a structure with functor '$java_object', and argument an integer given by the java side).")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_object/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg2")]),string_esc(" "),string_esc("is a java event represented as an atom with the full event constructor name (e.g., 'java.awt.event.ActionListener').")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:java_event/1")],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Arg3")]),string_esc(" "),string_esc("is a prolog predicate. Prolog term that represents the goal that must be invoked when the event raises on the object. The predicate arguments can be java objects, or even the result of java methods. These java objects will be evaluated when the event raises (instead of when the listener is added). The arguments that represent java objects must be instantiated to already created objects. The variables will be kept uninstantiated when the event raises and the predicate is called.")],raw_nl],[[],[string_esc(" ("),[string_esc("javart:prolog_goal/1")],string_esc(")")]])]],raw_nl],[],[]))]]]),sp("1"),raw_nl]]),[],[]]]).